# 变量

* 声明变量的通用形式

  > var name type = expression

* go变量声明特点:
  
  1. 不比强制值初始化,int自动初始化,string自动为""等.
  2. 支持同时声明不同的变量
     > var i, j, k int    //int, int, int  
     > var b,f,s = int, bool, string

## 2.31 短变量声明

* 函数里,声明初始化局部变量可以用短变量声明的形式进行,并且支持多变量声明;

  > name1, name2 := type1, type2

* `:=` 表示声明, `=` 表示赋值

  > i, j = j, i  //交换两者的值

* 若已经申明了一个变量,再继续使用 `:=` 时需保证至少还有一个新变量
  > a := 1  
  > a, err := orm.QuereTable().Values() //err 为新变量, a为赋值操作

## 2.32 指针

* 指针是变量的地址.

* ```go
  var x int
  //表达式&x 获取x的地址, 即为指向一个整型变量的指针, 其类型为 *int
  x = 1
  p = &x
  //p指向x	p包含x的地址
  //*p == 1
  *p = 2
  fmt.Println(x)	//2
  ```

* 

## 2.33 new函数

* 内置new函数可以创建变量,表达式为new(T),初始化T类型的零值,并返回地址(地址类型为*T).

  > p := new(int)

## 2.34 变量的声明周期

* 包级别的变量声明周期为整个程序执行的时间.
* 编译器可以分配堆与栈上的内存,但是与c/cpp不同,不是通过`var`或`new`来声明变量.例如:

  ```
  var global *int
  func f() {
      var x int
      x = 1
      global = &x
  }
  ```

  在此处,x使用了堆空间,因为在函数结束返回以后还可以访问,尽管其为局部变量.`这种情况称为x从f中逃逸`.
* 在写代码的时候不用去花心思考虑内存分配,但是为了高效代码或者性能优化的时候可以从此处入手,变量逃逸会需要额外的内存分配.